import { QueryClient, QueryObserver, InfiniteQueryObserver, isCancelledError } from 'react-query';
import { atom } from 'jotai';

const queryClientAtom = atom(new QueryClient());

function atomWithQuery(createQuery, getQueryClient = (get) => get(queryClientAtom)) {
  const queryDataAtom = atom((get) => {
    const queryClient = getQueryClient(get);
    const options = typeof createQuery === "function" ? createQuery(get) : createQuery;
    const defaultedOptions = queryClient.defaultQueryOptions(options);
    const observer = new QueryObserver(queryClient, defaultedOptions);
    const initialResult = observer.getCurrentResult();
    let resolve = null;
    const resultAtom = atom(initialResult.data === void 0 && options.enabled !== false ? new Promise((r) => {
      resolve = r;
    }) : initialResult);
    let setResult = () => {
      throw new Error("setting result without mount");
    };
    const state = {
      isMounted: false,
      unsubscribe: null
    };
    const listener = (result) => {
      if (result.isFetching || !result.isError && result.data === void 0) {
        return;
      }
      if (resolve) {
        setTimeout(() => {
          var _a;
          if (!state.isMounted) {
            (_a = state.unsubscribe) == null ? void 0 : _a.call(state);
            state.unsubscribe = null;
          }
        }, 1e3);
        resolve(result);
        resolve = null;
      } else {
        setResult(result);
      }
    };
    if (options.enabled !== false) {
      state.unsubscribe = observer.subscribe(listener);
    }
    resultAtom.onMount = (update) => {
      setResult = update;
      state.isMounted = true;
      if (options.enabled !== false && !state.unsubscribe) {
        state.unsubscribe = observer.subscribe(listener);
        listener(observer.getCurrentResult());
      }
      return () => {
        var _a;
        return (_a = state.unsubscribe) == null ? void 0 : _a.call(state);
      };
    };
    return { options, resultAtom, observer, state };
  }, (get, set, action) => {
    var _a;
    const { options, resultAtom, observer, state } = get(queryDataAtom);
    if (options.enabled === false) {
      return;
    }
    switch (action.type) {
      case "refetch": {
        set(resultAtom, new Promise(() => {
        }));
        if (!state.isMounted) {
          (_a = state.unsubscribe) == null ? void 0 : _a.call(state);
          state.unsubscribe = null;
        }
        return observer.refetch({ cancelRefetch: true }).then((result) => {
          set(resultAtom, result);
        });
      }
    }
  });
  const queryAtom = atom((get) => {
    const { resultAtom } = get(queryDataAtom);
    const result = get(resultAtom);
    if (result.isError) {
      throw result.error;
    }
    return result.data;
  }, (_get, set, action) => set(queryDataAtom, action));
  return queryAtom;
}

function atomWithInfiniteQuery(createQuery, getQueryClient = (get) => get(queryClientAtom)) {
  const queryDataAtom = atom((get) => {
    const queryClient = getQueryClient(get);
    const options = typeof createQuery === "function" ? createQuery(get) : createQuery;
    const defaultedOptions = queryClient.defaultQueryOptions(options);
    const observer = new InfiniteQueryObserver(queryClient, defaultedOptions);
    const initialResult = observer.getCurrentResult();
    let resolve = null;
    const resultAtom = atom(initialResult.data === void 0 && options.enabled !== false ? new Promise((r) => {
      resolve = r;
    }) : initialResult);
    let setResult = () => {
      throw new Error("setting result without mount");
    };
    const state = {
      isMounted: false,
      unsubscribe: null
    };
    const listener = (result) => {
      if (result.isFetching || !result.isError && result.data === void 0 || result.isError && isCancelledError(result.error)) {
        return;
      }
      if (resolve) {
        setTimeout(() => {
          var _a;
          if (!state.isMounted) {
            (_a = state.unsubscribe) == null ? void 0 : _a.call(state);
            state.unsubscribe = null;
          }
        }, 1e3);
        resolve(result);
        resolve = null;
      } else {
        setResult(result);
      }
    };
    if (options.enabled !== false) {
      state.unsubscribe = observer.subscribe(listener);
    }
    resultAtom.onMount = (update) => {
      setResult = update;
      state.isMounted = true;
      if (options.enabled !== false && !state.unsubscribe) {
        state.unsubscribe = observer.subscribe(listener);
        listener(observer.getCurrentResult());
      }
      return () => {
        var _a;
        return (_a = state.unsubscribe) == null ? void 0 : _a.call(state);
      };
    };
    return { options, resultAtom, observer, state };
  }, (get, set, action) => {
    var _a;
    const { options, resultAtom, observer, state } = get(queryDataAtom);
    if (options.enabled === false) {
      return;
    }
    switch (action.type) {
      case "refetch": {
        set(resultAtom, new Promise(() => {
        }));
        if (!state.isMounted) {
          (_a = state.unsubscribe) == null ? void 0 : _a.call(state);
          state.unsubscribe = null;
        }
        const { type: _type, ...rest } = action;
        observer.refetch(rest).then((result) => {
          set(resultAtom, result);
        });
        return;
      }
      case "fetchPreviousPage": {
        observer.fetchPreviousPage();
        return;
      }
      case "fetchNextPage": {
        observer.fetchNextPage();
        return;
      }
    }
  });
  const queryAtom = atom((get) => {
    const { resultAtom } = get(queryDataAtom);
    const result = get(resultAtom);
    if (result.isError) {
      throw result.error;
    }
    return result.data;
  }, (_get, set, action) => set(queryDataAtom, action));
  return queryAtom;
}

export { atomWithInfiniteQuery, atomWithQuery, queryClientAtom };
